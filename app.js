const canvas = document.querySelector('canvas');
const instructions = document.getElementById('instructions');

// not sure how to resize the bauble player so just forcing 1080p
canvas.width = 1920;
canvas.height = 1080;

/*
(reduce
  (fn [shape _]
    (shape
      | rotate x (t / 20) y (t / 20)
      | rotate y (t / 20 + 0.5) y (t / 20 + 0.5)
      | move x 20
      | mirror x
    )
  )
  (box 20)
  (range 15)
)
*/

const bauble = new Bauble(canvas, {
    source: "#version 300 es\nprecision highp float;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nout vec4 frag_color;\n\nuniform float free_camera_zoom;\nuniform vec3 free_camera_target;\nuniform vec2 free_camera_orbit;\nuniform float t;\nuniform vec4 viewport;\n\nmat2 rotation_2d(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, s, -s, c);\n}\n\nfloat max_(vec2 v) {\n  return max(v.x, v.y);\n}\n\nmat3 rotation_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotation_x(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n}\n\nvec3 perspective_vector(float fov, vec2 frag_coord) {\n  float cot_half_fov = tan(radians(90.0 - (fov * 0.5)));\n  return normalize(vec3(frag_coord, cot_half_fov));\n}\n\nfloat max_1(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat sdf_cube(float size, vec3 p) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.0)) + min(max_1(d), 0.0);\n}\n\nfloat rotate_outer(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return sdf_cube(20.0, p1);\n  }\n}\n\nfloat rotate_outer1(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer(p1, t);\n  }\n}\n\nfloat move_outer(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer1(p1, t);\n  }\n}\n\nfloat map_axes_outer(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer(p1, t);\n  }\n}\n\nfloat rotate_outer2(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer(p1, t);\n  }\n}\n\nfloat rotate_outer3(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer2(p1, t);\n  }\n}\n\nfloat move_outer1(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer3(p1, t);\n  }\n}\n\nfloat map_axes_outer1(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer1(p1, t);\n  }\n}\n\nfloat rotate_outer4(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer1(p1, t);\n  }\n}\n\nfloat rotate_outer5(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer4(p1, t);\n  }\n}\n\nfloat move_outer2(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer5(p1, t);\n  }\n}\n\nfloat map_axes_outer2(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer2(p1, t);\n  }\n}\n\nfloat rotate_outer6(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer2(p1, t);\n  }\n}\n\nfloat rotate_outer7(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer6(p1, t);\n  }\n}\n\nfloat move_outer3(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer7(p1, t);\n  }\n}\n\nfloat map_axes_outer3(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer3(p1, t);\n  }\n}\n\nfloat rotate_outer8(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer3(p1, t);\n  }\n}\n\nfloat rotate_outer9(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer8(p1, t);\n  }\n}\n\nfloat move_outer4(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer9(p1, t);\n  }\n}\n\nfloat map_axes_outer4(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer4(p1, t);\n  }\n}\n\nfloat rotate_outer10(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer4(p1, t);\n  }\n}\n\nfloat rotate_outer11(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer10(p1, t);\n  }\n}\n\nfloat move_outer5(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer11(p1, t);\n  }\n}\n\nfloat map_axes_outer5(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer5(p1, t);\n  }\n}\n\nfloat rotate_outer12(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer5(p1, t);\n  }\n}\n\nfloat rotate_outer13(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer12(p1, t);\n  }\n}\n\nfloat move_outer6(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer13(p1, t);\n  }\n}\n\nfloat map_axes_outer6(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer6(p1, t);\n  }\n}\n\nfloat rotate_outer14(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer6(p1, t);\n  }\n}\n\nfloat rotate_outer15(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer14(p1, t);\n  }\n}\n\nfloat move_outer7(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer15(p1, t);\n  }\n}\n\nfloat map_axes_outer7(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer7(p1, t);\n  }\n}\n\nfloat rotate_outer16(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer7(p1, t);\n  }\n}\n\nfloat rotate_outer17(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer16(p1, t);\n  }\n}\n\nfloat move_outer8(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer17(p1, t);\n  }\n}\n\nfloat map_axes_outer8(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer8(p1, t);\n  }\n}\n\nfloat rotate_outer18(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer8(p1, t);\n  }\n}\n\nfloat rotate_outer19(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer18(p1, t);\n  }\n}\n\nfloat move_outer9(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer19(p1, t);\n  }\n}\n\nfloat map_axes_outer9(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer9(p1, t);\n  }\n}\n\nfloat rotate_outer20(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer9(p1, t);\n  }\n}\n\nfloat rotate_outer21(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer20(p1, t);\n  }\n}\n\nfloat move_outer10(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer21(p1, t);\n  }\n}\n\nfloat map_axes_outer10(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer10(p1, t);\n  }\n}\n\nfloat rotate_outer22(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer10(p1, t);\n  }\n}\n\nfloat rotate_outer23(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer22(p1, t);\n  }\n}\n\nfloat move_outer11(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer23(p1, t);\n  }\n}\n\nfloat map_axes_outer11(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer11(p1, t);\n  }\n}\n\nfloat rotate_outer24(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer11(p1, t);\n  }\n}\n\nfloat rotate_outer25(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer24(p1, t);\n  }\n}\n\nfloat move_outer12(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer25(p1, t);\n  }\n}\n\nfloat map_axes_outer12(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer12(p1, t);\n  }\n}\n\nfloat rotate_outer26(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer12(p1, t);\n  }\n}\n\nfloat rotate_outer27(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer26(p1, t);\n  }\n}\n\nfloat move_outer13(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer27(p1, t);\n  }\n}\n\nfloat map_axes_outer13(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer13(p1, t);\n  }\n}\n\nfloat rotate_outer28(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(t / 20.0) * rotation_y(t / 20.0));\n    return map_axes_outer13(p1, t);\n  }\n}\n\nfloat rotate_outer29(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_y((t / 20.0) + 0.5) * rotation_y((t / 20.0) + 0.5));\n    return rotate_outer28(p1, t);\n  }\n}\n\nfloat move_outer14(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(1.0, 0.0, 0.0) * 20.0);\n    return rotate_outer29(p1, t);\n  }\n}\n\nfloat map_axes_outer14(vec3 p, float t) {\n  {\n    vec3 p1 = vec3(abs(p.x), p.y, p.z);\n    return move_outer14(p1, t);\n  }\n}\n\nfloat nearest_distance(vec3 p, float t) {\n  return map_axes_outer14(p, t);\n}\n\nfloat march(out uint steps, Ray ray, float t) {\n  float ray_depth = 0.0;\n  for (steps = 0u; steps < 256u; ++steps) {\n    {\n      float depth = ray_depth;\n      vec3 P = ray.origin + (ray_depth * ray.direction);\n      vec3 p = P;\n      float dist = nearest_distance(p, t);\n      if (((dist >= 0.0) && (dist < 0.1)) || (ray_depth > 65536.0)) return ray_depth;\n      float rate = (dist > 0.0) ? 0.95 : 1.05;\n      ray_depth += dist * rate;\n      if (ray_depth < 0.0) return 0.0;\n    }\n  }\n  return ray_depth;\n}\n\nfloat with_outer(vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xyy * 0.005) + p;\n    return nearest_distance(p1, t);\n  }\n}\n\nfloat with_outer1(vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yyx * 0.005) + p;\n    return nearest_distance(p1, t);\n  }\n}\n\nfloat with_outer2(vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yxy * 0.005) + p;\n    return nearest_distance(p1, t);\n  }\n}\n\nfloat with_outer3(vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xxx * 0.005) + p;\n    return nearest_distance(p1, t);\n  }\n}\n\nvec3 do_(vec2 Frag_Coord, vec2 resolution) {\n  const vec3 light = pow(vec3(69.0, 72.0, 79.0) / 255.0, vec3(2.2));\n  const vec3 dark = pow(vec3(40.0, 42.0, 46.0) / 255.0, vec3(2.2));\n  return vec3(mix(dark, light, (Frag_Coord.x + Frag_Coord.y) / (resolution.x + resolution.y)));\n}\n\nfloat fresnel(float exponent, vec3 normal, Ray ray) {\n  return pow(1.0 + dot(normal, ray.direction), exponent);\n}\n\nvec4 sample_(vec2 Frag_Coord, vec2 frag_coord, vec2 free_camera_orbit, float free_camera_zoom, vec3 free_camera_target, vec2 resolution, float t) {\n  Ray ray_star = Ray(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n  vec3 ortho_quad = vec3(0.0, 0.0, 0.0);\n  float ortho_scale = 0.0;\n  float fov = 0.0;\n  mat3 camera_rotation_matrix = rotation_y(6.28318530717959 * free_camera_orbit.x) * rotation_x(6.28318530717959 * free_camera_orbit.y);\n  ray_star = Ray((camera_rotation_matrix * vec3(0.0, 0.0, 512.0 * free_camera_zoom)) + free_camera_target, camera_rotation_matrix * (perspective_vector(45.0, frag_coord) * vec3(1.0, 1.0, -1.0)));\n  uint steps = 0u;\n  {\n    Ray ray = ray_star;\n    float depth = march(steps, ray, t);\n    vec3 P = ray.origin + (ray.direction * depth);\n    vec3 p = P;\n    float dist = nearest_distance(p, t);\n    vec3 normal = normalize((vec2(1.0, -1.0).xyy * with_outer(p, t)) + (vec2(1.0, -1.0).yyx * with_outer1(p, t)) + (vec2(1.0, -1.0).yxy * with_outer2(p, t)) + (vec2(1.0, -1.0).xxx * with_outer3(p, t)));\n    vec4 color = vec4(0.0);\n    color = (dist >= 10.0) ? vec4(do_(Frag_Coord, resolution), 1.0) : vec4(mix((normal + 1.0) * 0.5, vec3(1.0, 1.0, 1.0), fresnel(5.0, normal, ray)), 1.0);\n    return color;\n  }\n}\n\nvec3 pow_(vec3 v, float e) {\n  return pow(v, vec3(e));\n}\n\nvoid main() {\n  const float gamma = 2.2;\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  float alpha = 0.0;\n  const uint aa_grid_size = 1u;\n  const float aa_sample_width = 1.0 / float(1u + aa_grid_size);\n  const vec2 pixel_origin = vec2(0.5, 0.5);\n  vec2 local_frag_coord = gl_FragCoord.xy - viewport.xy;\n  mat2 rotation = rotation_2d(0.2);\n  for (uint y = 1u; y <= aa_grid_size; ++y) {\n    for (uint x = 1u; x <= aa_grid_size; ++x) {\n      vec2 sample_offset = (aa_sample_width * vec2(float(x), float(y))) - pixel_origin;\n      sample_offset = rotation * sample_offset;\n      sample_offset = fract(sample_offset + pixel_origin) - pixel_origin;\n      {\n        vec2 Frag_Coord = local_frag_coord + sample_offset;\n        vec2 resolution = viewport.zw;\n        vec2 frag_coord = ((Frag_Coord - (0.5 * resolution)) / max_(resolution)) * 2.0;\n        vec4 this_sample = clamp(sample_(Frag_Coord, frag_coord, free_camera_orbit, free_camera_zoom, free_camera_target, resolution, t), 0.0, 1.0);\n        color += this_sample.rgb * this_sample.a;\n        alpha += this_sample.a;\n      }\n    }\n  }\n  if (alpha > 0.0) {\n    color = color / alpha;\n    alpha /= float(aa_grid_size * aa_grid_size);\n  }\n  frag_color = vec4(pow_(color, 1.0 / gamma), alpha);\n}\n",
    animation: false, // wait for keypress to start
    interaction: false,
});


document.addEventListener('keydown', (e) => {
    if (e.key === 'f') {
        if (!document.fullscreenElement) {
            document.body.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }

    if (e.key === ' ') {
        bauble.togglePlay();
        instructions.style.display = 'none';
        canvas.style.display = 'block';
        document.getElementById('music').play();
    }
});